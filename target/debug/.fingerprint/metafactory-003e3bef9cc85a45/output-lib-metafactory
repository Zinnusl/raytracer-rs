{"message":"expected parameter name, found `:`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs","byte_start":4215,"byte_end":4216,"line_start":109,"line_end":109,"column_start":27,"column_end":28,"is_primary":true,"text":[{"text":"            do_new: box |&: items: Vec<Box<Any>>| {","highlight_start":27,"highlight_end":28}],"label":"expected parameter name","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs","byte_start":4080,"byte_end":4089,"line_start":106,"line_end":106,"column_start":9,"column_end":18,"is_primary":false,"text":[{"text":"        Aggregate {","highlight_start":9,"highlight_end":18}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected parameter name, found `:`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs:109:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Aggregate {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            do_new: box |&: items: Vec<Box<Any>>| {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected parameter name\u001b[0m\n\n"}
{"message":"`box_syntax` has been removed","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs","byte_start":6009,"byte_end":6025,"line_start":178,"line_end":178,"column_start":9,"column_end":25,"is_primary":true,"text":[{"text":"        box self.clone()","highlight_start":9,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use `Box::new()` instead","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs","byte_start":6009,"byte_end":6025,"line_start":178,"line_end":178,"column_start":9,"column_end":25,"is_primary":true,"text":[{"text":"        box self.clone()","highlight_start":9,"highlight_end":25}],"label":null,"suggested_replacement":"Box::new(self.clone())","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: `box_syntax` has been removed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs:178:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        box self.clone()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use `Box::new()` instead\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mBox::new(self.clone())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"`box_syntax` has been removed","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/factory/mod.rs","byte_start":558,"byte_end":584,"line_start":24,"line_end":24,"column_start":22,"column_end":48,"is_primary":true,"text":[{"text":"        let boxany = box create_with_val(\"HAI\") as Box<Any>;","highlight_start":22,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use `Box::new()` instead","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/factory/mod.rs","byte_start":558,"byte_end":584,"line_start":24,"line_end":24,"column_start":22,"column_end":48,"is_primary":true,"text":[{"text":"        let boxany = box create_with_val(\"HAI\") as Box<Any>;","highlight_start":22,"highlight_end":48}],"label":null,"suggested_replacement":"Box::new(create_with_val(\"HAI\"))","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: `box_syntax` has been removed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/factory/mod.rs:24:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let boxany = box create_with_val(\"HAI\") as Box<Any>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use `Box::new()` instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let boxany = \u001b[0m\u001b[0m\u001b[38;5;10mBox::new(create_with_val(\"HAI\"))\u001b[0m\u001b[0m as Box<Any>;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"message":"`box_syntax` has been removed","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/factory/mod.rs","byte_start":796,"byte_end":837,"line_start":31,"line_end":31,"column_start":22,"column_end":63,"is_primary":true,"text":[{"text":"        Factory::new(box ValContainer { val: val.to_string() })","highlight_start":22,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use `Box::new()` instead","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/factory/mod.rs","byte_start":796,"byte_end":837,"line_start":31,"line_end":31,"column_start":22,"column_end":63,"is_primary":true,"text":[{"text":"        Factory::new(box ValContainer { val: val.to_string() })","highlight_start":22,"highlight_end":63}],"label":null,"suggested_replacement":"Box::new(ValContainer { val: val.to_string() })","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: `box_syntax` has been removed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/factory/mod.rs:31:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Factory::new(box ValContainer { val: val.to_string() })\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use `Box::new()` instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        Factory::new(\u001b[0m\u001b[0m\u001b[38;5;10mBox::new(ValContainer { val: val.to_string() })\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"message":"`box_syntax` has been removed","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/factory/mod.rs","byte_start":1094,"byte_end":1165,"line_start":44,"line_end":46,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            box ValContainer {","highlight_start":13,"highlight_end":31},{"text":"                val: self.val.clone(),","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use `Box::new()` instead","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/factory/mod.rs","byte_start":1094,"byte_end":1165,"line_start":44,"line_end":46,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            box ValContainer {","highlight_start":13,"highlight_end":31},{"text":"                val: self.val.clone(),","highlight_start":1,"highlight_end":39},{"text":"            }","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"Box::new(ValContainer {\n                val: self.val.clone(),\n            })","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: `box_syntax` has been removed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/factory/mod.rs:44:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            box ValContainer {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                val: self.val.clone(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____________^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use `Box::new()` instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mBox::new(ValContainer {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 val: self.val.clone(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+             })\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"`box_syntax` has been removed","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":1064,"byte_end":1105,"line_start":43,"line_end":43,"column_start":9,"column_end":50,"is_primary":true,"text":[{"text":"        box CloneableMetaFactory { value : self }","highlight_start":9,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use `Box::new()` instead","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":1064,"byte_end":1105,"line_start":43,"line_end":43,"column_start":9,"column_end":50,"is_primary":true,"text":[{"text":"        box CloneableMetaFactory { value : self }","highlight_start":9,"highlight_end":50}],"label":null,"suggested_replacement":"Box::new(CloneableMetaFactory { value : self })","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: `box_syntax` has been removed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs:43:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        box CloneableMetaFactory { value : self }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use `Box::new()` instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mBox::new(CloneableMetaFactory { value : self })\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"`box_syntax` has been removed","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":1469,"byte_end":1522,"line_start":59,"line_end":59,"column_start":17,"column_end":70,"is_primary":true,"text":[{"text":"                box CloneableValue::<T> { value: self.value.clone() }","highlight_start":17,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use `Box::new()` instead","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":1469,"byte_end":1522,"line_start":59,"line_end":59,"column_start":17,"column_end":70,"is_primary":true,"text":[{"text":"                box CloneableValue::<T> { value: self.value.clone() }","highlight_start":17,"highlight_end":70}],"label":null,"suggested_replacement":"Box::new(CloneableValue::<T> { value: self.value.clone() })","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: `box_syntax` has been removed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs:59:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                box CloneableValue::<T> { value: self.value.clone() }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use `Box::new()` instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[38;5;10mBox::new(CloneableValue::<T> { value: self.value.clone() })\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"`box_syntax` has been removed","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":1435,"byte_end":1536,"line_start":58,"line_end":60,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            box Factory::new(","highlight_start":13,"highlight_end":30},{"text":"                box CloneableValue::<T> { value: self.value.clone() }","highlight_start":1,"highlight_end":70},{"text":"            ) as Box<Any>","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use `Box::new()` instead","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":1435,"byte_end":1536,"line_start":58,"line_end":60,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            box Factory::new(","highlight_start":13,"highlight_end":30},{"text":"                box CloneableValue::<T> { value: self.value.clone() }","highlight_start":1,"highlight_end":70},{"text":"            ) as Box<Any>","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":"Box::new(Factory::new(\n                box CloneableValue::<T> { value: self.value.clone() }\n            ))","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: `box_syntax` has been removed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs:58:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m            box Factory::new(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                box CloneableValue::<T> { value: self.value.clone() }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            ) as Box<Any>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____________^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use `Box::new()` instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m58\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10mBox::new(Factory::new(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+                 box CloneableValue::<T> { value: self.value.clone() }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~             ))\u001b[0m\u001b[0m as Box<Any>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"`box_syntax` has been removed","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":1840,"byte_end":1893,"line_start":75,"line_end":75,"column_start":9,"column_end":62,"is_primary":true,"text":[{"text":"        box CloneableValue::<T> { value: self.value.clone() }","highlight_start":9,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use `Box::new()` instead","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":1840,"byte_end":1893,"line_start":75,"line_end":75,"column_start":9,"column_end":62,"is_primary":true,"text":[{"text":"        box CloneableValue::<T> { value: self.value.clone() }","highlight_start":9,"highlight_end":62}],"label":null,"suggested_replacement":"Box::new(CloneableValue::<T> { value: self.value.clone() })","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: `box_syntax` has been removed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs:75:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m75\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        box CloneableValue::<T> { value: self.value.clone() }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use `Box::new()` instead\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m75\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mBox::new(CloneableValue::<T> { value: self.value.clone() })\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"expected type, found `||`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/zeroarg.rs","byte_start":1019,"byte_end":1021,"line_start":38,"line_end":38,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"impl<T:'static> ToMetaFactory for (||:'static -> T) {","highlight_start":36,"highlight_end":38}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `||`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/zeroarg.rs:38:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<T:'static> ToMetaFactory for (||:'static -> T) {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\n"}
{"message":"expected one of `>`, a const expression, lifetime, or type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2842,"byte_end":2843,"line_start":92,"line_end":92,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":37,"highlight_end":38}],"label":"expected one of `>`, a const expression, lifetime, or type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6562,"byte_end":6616,"line_start":186,"line_end":189,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope:","highlight_start":1,"highlight_end":17},{"text":"    A, A, a","highlight_start":1,"highlight_end":12},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6590,"byte_end":6601,"line_start":187,"line_end":187,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"    GetterScope:","highlight_start":5,"highlight_end":16}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `>`, a const expression, lifetime, or type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:92:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `>`, a const expression, lifetime, or type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope:\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m188\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A, A, a\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m189\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":3056,"byte_end":3057,"line_start":97,"line_end":97,"column_start":67,"column_end":68,"is_primary":true,"text":[{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":67,"highlight_end":68}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6562,"byte_end":6616,"line_start":186,"line_end":189,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope:","highlight_start":1,"highlight_end":17},{"text":"    A, A, a","highlight_start":1,"highlight_end":12},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:97:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m188\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A, A, a\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m189\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected one of `>`, a const expression, lifetime, or type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2842,"byte_end":2843,"line_start":92,"line_end":92,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":37,"highlight_end":38}],"label":"expected one of `>`, a const expression, lifetime, or type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6619,"byte_end":6694,"line_start":191,"line_end":195,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope2:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6647,"byte_end":6659,"line_start":192,"line_end":192,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"    GetterScope2:","highlight_start":5,"highlight_end":17}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `>`, a const expression, lifetime, or type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:92:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `>`, a const expression, lifetime, or type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m191\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m192\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope2:\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m193\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":3056,"byte_end":3057,"line_start":97,"line_end":97,"column_start":67,"column_end":68,"is_primary":true,"text":[{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":67,"highlight_end":68}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6619,"byte_end":6694,"line_start":191,"line_end":195,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope2:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:97:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m191\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m192\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope2:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m193\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m195\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected one of `>`, a const expression, lifetime, or type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2842,"byte_end":2843,"line_start":92,"line_end":92,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":37,"highlight_end":38}],"label":"expected one of `>`, a const expression, lifetime, or type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6697,"byte_end":6789,"line_start":197,"line_end":202,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope3:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6725,"byte_end":6737,"line_start":198,"line_end":198,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"    GetterScope3:","highlight_start":5,"highlight_end":17}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `>`, a const expression, lifetime, or type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:92:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `>`, a const expression, lifetime, or type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope3:\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m201\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A3, A3, a3\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":3056,"byte_end":3057,"line_start":97,"line_end":97,"column_start":67,"column_end":68,"is_primary":true,"text":[{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":67,"highlight_end":68}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6697,"byte_end":6789,"line_start":197,"line_end":202,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope3:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:97:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m197\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope3:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m201\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A3, A3, a3\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected one of `>`, a const expression, lifetime, or type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2842,"byte_end":2843,"line_start":92,"line_end":92,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":37,"highlight_end":38}],"label":"expected one of `>`, a const expression, lifetime, or type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6792,"byte_end":6901,"line_start":204,"line_end":210,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope4:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6820,"byte_end":6832,"line_start":205,"line_end":205,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"    GetterScope4:","highlight_start":5,"highlight_end":17}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `>`, a const expression, lifetime, or type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:92:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `>`, a const expression, lifetime, or type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m205\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope4:\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m207\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A3, A3, a3 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m209\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A4, A4, a4\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m210\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":3056,"byte_end":3057,"line_start":97,"line_end":97,"column_start":67,"column_end":68,"is_primary":true,"text":[{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":67,"highlight_end":68}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6792,"byte_end":6901,"line_start":204,"line_end":210,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope4:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:97:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m204\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m205\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope4:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m206\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m207\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A3, A3, a3 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m209\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A4, A4, a4\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m210\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected one of `>`, a const expression, lifetime, or type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2842,"byte_end":2843,"line_start":92,"line_end":92,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":37,"highlight_end":38}],"label":"expected one of `>`, a const expression, lifetime, or type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6904,"byte_end":7030,"line_start":212,"line_end":219,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope5:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6932,"byte_end":6944,"line_start":213,"line_end":213,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"    GetterScope5:","highlight_start":5,"highlight_end":17}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `>`, a const expression, lifetime, or type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:92:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `>`, a const expression, lifetime, or type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope5:\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m214\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m215\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m218\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A5, A5, a5\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":3056,"byte_end":3057,"line_start":97,"line_end":97,"column_start":67,"column_end":68,"is_primary":true,"text":[{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":67,"highlight_end":68}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":6904,"byte_end":7030,"line_start":212,"line_end":219,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope5:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:97:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m213\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope5:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m214\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m215\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m218\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A5, A5, a5\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m219\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected one of `>`, a const expression, lifetime, or type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2842,"byte_end":2843,"line_start":92,"line_end":92,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":37,"highlight_end":38}],"label":"expected one of `>`, a const expression, lifetime, or type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7033,"byte_end":7176,"line_start":221,"line_end":229,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope6:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7061,"byte_end":7073,"line_start":222,"line_end":222,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"    GetterScope6:","highlight_start":5,"highlight_end":17}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `>`, a const expression, lifetime, or type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:92:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `>`, a const expression, lifetime, or type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m221\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m222\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope6:\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m223\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m228\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A6, A6, a6\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m229\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":3056,"byte_end":3057,"line_start":97,"line_end":97,"column_start":67,"column_end":68,"is_primary":true,"text":[{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":67,"highlight_end":68}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7033,"byte_end":7176,"line_start":221,"line_end":229,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope6:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:97:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m221\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m222\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope6:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m223\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m228\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A6, A6, a6\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m229\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected one of `>`, a const expression, lifetime, or type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2842,"byte_end":2843,"line_start":92,"line_end":92,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":37,"highlight_end":38}],"label":"expected one of `>`, a const expression, lifetime, or type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7179,"byte_end":7339,"line_start":231,"line_end":240,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope7:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6 |","highlight_start":1,"highlight_end":17},{"text":"    A7, A7, a7","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7207,"byte_end":7219,"line_start":232,"line_end":232,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"    GetterScope7:","highlight_start":5,"highlight_end":17}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `>`, a const expression, lifetime, or type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:92:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `>`, a const expression, lifetime, or type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m232\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope7:\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m233\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m239\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A7, A7, a7\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m240\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":3056,"byte_end":3057,"line_start":97,"line_end":97,"column_start":67,"column_end":68,"is_primary":true,"text":[{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":67,"highlight_end":68}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7179,"byte_end":7339,"line_start":231,"line_end":240,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope7:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6 |","highlight_start":1,"highlight_end":17},{"text":"    A7, A7, a7","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:97:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m231\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m232\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope7:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m233\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m234\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m239\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A7, A7, a7\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m240\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected one of `>`, a const expression, lifetime, or type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2842,"byte_end":2843,"line_start":92,"line_end":92,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":37,"highlight_end":38}],"label":"expected one of `>`, a const expression, lifetime, or type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7342,"byte_end":7519,"line_start":242,"line_end":252,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope8:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6 |","highlight_start":1,"highlight_end":17},{"text":"    A7, A7, a7 |","highlight_start":1,"highlight_end":17},{"text":"    A8, A8, a8","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7370,"byte_end":7382,"line_start":243,"line_end":243,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"    GetterScope8:","highlight_start":5,"highlight_end":17}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `>`, a const expression, lifetime, or type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:92:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `>`, a const expression, lifetime, or type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m242\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m243\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope8:\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m244\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m245\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m251\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A8, A8, a8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m252\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":3056,"byte_end":3057,"line_start":97,"line_end":97,"column_start":67,"column_end":68,"is_primary":true,"text":[{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":67,"highlight_end":68}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7342,"byte_end":7519,"line_start":242,"line_end":252,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope8:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6 |","highlight_start":1,"highlight_end":17},{"text":"    A7, A7, a7 |","highlight_start":1,"highlight_end":17},{"text":"    A8, A8, a8","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:97:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m242\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m243\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope8:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m244\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m245\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m251\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A8, A8, a8\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m252\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected one of `>`, a const expression, lifetime, or type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2842,"byte_end":2843,"line_start":92,"line_end":92,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":37,"highlight_end":38}],"label":"expected one of `>`, a const expression, lifetime, or type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7522,"byte_end":7716,"line_start":254,"line_end":265,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope9:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6 |","highlight_start":1,"highlight_end":17},{"text":"    A7, A7, a7 |","highlight_start":1,"highlight_end":17},{"text":"    A8, A8, a8 |","highlight_start":1,"highlight_end":17},{"text":"    A9, A9, a9","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7550,"byte_end":7562,"line_start":255,"line_end":255,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"    GetterScope9:","highlight_start":5,"highlight_end":17}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `>`, a const expression, lifetime, or type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:92:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `>`, a const expression, lifetime, or type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m254\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m255\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope9:\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m256\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m257\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m264\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A9, A9, a9\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":3056,"byte_end":3057,"line_start":97,"line_end":97,"column_start":67,"column_end":68,"is_primary":true,"text":[{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":67,"highlight_end":68}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7522,"byte_end":7716,"line_start":254,"line_end":265,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope9:","highlight_start":1,"highlight_end":18},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6 |","highlight_start":1,"highlight_end":17},{"text":"    A7, A7, a7 |","highlight_start":1,"highlight_end":17},{"text":"    A8, A8, a8 |","highlight_start":1,"highlight_end":17},{"text":"    A9, A9, a9","highlight_start":1,"highlight_end":15},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:97:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m254\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m255\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope9:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m256\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m257\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m264\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A9, A9, a9\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected one of `>`, a const expression, lifetime, or type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2842,"byte_end":2843,"line_start":92,"line_end":92,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":37,"highlight_end":38}],"label":"expected one of `>`, a const expression, lifetime, or type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7719,"byte_end":7934,"line_start":267,"line_end":279,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope10:","highlight_start":1,"highlight_end":19},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6 |","highlight_start":1,"highlight_end":17},{"text":"    A7, A7, a7 |","highlight_start":1,"highlight_end":17},{"text":"    A8, A8, a8 |","highlight_start":1,"highlight_end":17},{"text":"    A9, A9, a9 |","highlight_start":1,"highlight_end":17},{"text":"    A10, A10, a10","highlight_start":1,"highlight_end":18},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7747,"byte_end":7760,"line_start":268,"line_end":268,"column_start":5,"column_end":18,"is_primary":false,"text":[{"text":"    GetterScope10:","highlight_start":5,"highlight_end":18}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `>`, a const expression, lifetime, or type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:92:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `>`, a const expression, lifetime, or type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m267\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m268\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope10:\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m270\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m278\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A10, A10, a10\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m279\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":3056,"byte_end":3057,"line_start":97,"line_end":97,"column_start":67,"column_end":68,"is_primary":true,"text":[{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":67,"highlight_end":68}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7719,"byte_end":7934,"line_start":267,"line_end":279,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope10:","highlight_start":1,"highlight_end":19},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6 |","highlight_start":1,"highlight_end":17},{"text":"    A7, A7, a7 |","highlight_start":1,"highlight_end":17},{"text":"    A8, A8, a8 |","highlight_start":1,"highlight_end":17},{"text":"    A9, A9, a9 |","highlight_start":1,"highlight_end":17},{"text":"    A10, A10, a10","highlight_start":1,"highlight_end":18},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:97:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m267\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m268\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope10:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m270\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m278\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A10, A10, a10\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m279\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected one of `>`, a const expression, lifetime, or type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2842,"byte_end":2843,"line_start":92,"line_end":92,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":37,"highlight_end":38}],"label":"expected one of `>`, a const expression, lifetime, or type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7937,"byte_end":8172,"line_start":281,"line_end":294,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope11:","highlight_start":1,"highlight_end":19},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6 |","highlight_start":1,"highlight_end":17},{"text":"    A7, A7, a7 |","highlight_start":1,"highlight_end":17},{"text":"    A8, A8, a8 |","highlight_start":1,"highlight_end":17},{"text":"    A9, A9, a9 |","highlight_start":1,"highlight_end":17},{"text":"    A10, A10, a10 |","highlight_start":1,"highlight_end":20},{"text":"    A11, A11, a11","highlight_start":1,"highlight_end":18},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7965,"byte_end":7978,"line_start":282,"line_end":282,"column_start":5,"column_end":18,"is_primary":false,"text":[{"text":"    GetterScope11:","highlight_start":5,"highlight_end":18}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `>`, a const expression, lifetime, or type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:92:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `>`, a const expression, lifetime, or type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m281\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m282\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope11:\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m283\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m293\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A11, A11, a11\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m294\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":3056,"byte_end":3057,"line_start":97,"line_end":97,"column_start":67,"column_end":68,"is_primary":true,"text":[{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":67,"highlight_end":68}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":7937,"byte_end":8172,"line_start":281,"line_end":294,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope11:","highlight_start":1,"highlight_end":19},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6 |","highlight_start":1,"highlight_end":17},{"text":"    A7, A7, a7 |","highlight_start":1,"highlight_end":17},{"text":"    A8, A8, a8 |","highlight_start":1,"highlight_end":17},{"text":"    A9, A9, a9 |","highlight_start":1,"highlight_end":17},{"text":"    A10, A10, a10 |","highlight_start":1,"highlight_end":20},{"text":"    A11, A11, a11","highlight_start":1,"highlight_end":18},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:97:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m281\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m282\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope11:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m283\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m284\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m293\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A11, A11, a11\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m294\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected one of `>`, a const expression, lifetime, or type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2842,"byte_end":2843,"line_start":92,"line_end":92,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":37,"highlight_end":38}],"label":"expected one of `>`, a const expression, lifetime, or type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":8175,"byte_end":8430,"line_start":296,"line_end":310,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope12:","highlight_start":1,"highlight_end":19},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6 |","highlight_start":1,"highlight_end":17},{"text":"    A7, A7, a7 |","highlight_start":1,"highlight_end":17},{"text":"    A8, A8, a8 |","highlight_start":1,"highlight_end":17},{"text":"    A9, A9, a9 |","highlight_start":1,"highlight_end":17},{"text":"    A10, A10, a10 |","highlight_start":1,"highlight_end":20},{"text":"    A11, A11, a11 |","highlight_start":1,"highlight_end":20},{"text":"    A12, A12, a12","highlight_start":1,"highlight_end":18},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":8203,"byte_end":8216,"line_start":297,"line_end":297,"column_start":5,"column_end":18,"is_primary":false,"text":[{"text":"    GetterScope12:","highlight_start":5,"highlight_end":18}],"label":"while parsing this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `>`, a const expression, lifetime, or type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:92:37\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m92\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `>`, a const expression, lifetime, or type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m296\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m297\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope12:\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing this struct\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m298\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m299\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m309\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A12, A12, a12\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m310\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"expected type, found `|`","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":3056,"byte_end":3057,"line_start":97,"line_end":97,"column_start":67,"column_end":68,"is_primary":true,"text":[{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":67,"highlight_end":68}],"label":"expected type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":8175,"byte_end":8430,"line_start":296,"line_end":310,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"many_arg_closure_impl!(","highlight_start":1,"highlight_end":24},{"text":"    GetterScope12:","highlight_start":1,"highlight_end":19},{"text":"    A1, A1, a1 |","highlight_start":1,"highlight_end":17},{"text":"    A2, A2, a2 |","highlight_start":1,"highlight_end":17},{"text":"    A3, A3, a3 |","highlight_start":1,"highlight_end":17},{"text":"    A4, A4, a4 |","highlight_start":1,"highlight_end":17},{"text":"    A5, A5, a5 |","highlight_start":1,"highlight_end":17},{"text":"    A6, A6, a6 |","highlight_start":1,"highlight_end":17},{"text":"    A7, A7, a7 |","highlight_start":1,"highlight_end":17},{"text":"    A8, A8, a8 |","highlight_start":1,"highlight_end":17},{"text":"    A9, A9, a9 |","highlight_start":1,"highlight_end":17},{"text":"    A10, A10, a10 |","highlight_start":1,"highlight_end":20},{"text":"    A11, A11, a11 |","highlight_start":1,"highlight_end":20},{"text":"    A12, A12, a12","highlight_start":1,"highlight_end":18},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"many_arg_closure_impl!","def_site_span":{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs","byte_start":2314,"byte_end":6558,"line_start":80,"line_end":183,"column_start":5,"column_end":7,"is_primary":false,"text":[{"text":"    macro_rules! many_arg_closure_impl(","highlight_start":5,"highlight_end":40},{"text":"        ($GetterScope:ident: $($_A:ident,$_AT:ty,$_a:ident)|+)","highlight_start":1,"highlight_end":63},{"text":"        =>","highlight_start":1,"highlight_end":11},{"text":"        (","highlight_start":1,"highlight_end":10},{"text":"            /// Contains references to parent factories, so they","highlight_start":1,"highlight_end":65},{"text":"            /// can be invoked directly to get arguments for the closure.","highlight_start":1,"highlight_end":74},{"text":"            struct $GetterScope<$($_A:'static), +, T:'static> {","highlight_start":1,"highlight_end":64},{"text":"                // References to argument factories.","highlight_start":1,"highlight_end":53},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $_a: Factory<$_AT>,","highlight_start":1,"highlight_end":40},{"text":"                )+","highlight_start":1,"highlight_end":19},{"text":"                // Closure reference.","highlight_start":1,"highlight_end":38},{"text":"                closure: Rc<RefCell<|$($_AT), +|:'static -> T>>,","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Implement `ToMetaFactory` conversion for closures","highlight_start":1,"highlight_end":66},{"text":"            /// |A1, A2, ... AN| -> T","highlight_start":1,"highlight_end":38},{"text":"            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {","highlight_start":1,"highlight_end":95},{"text":"                fn to_metafactory<'a>(self) -> Box<MetaFactory + 'a> {","highlight_start":1,"highlight_end":71},{"text":"                    box Rc::new(RefCell::new(self))","highlight_start":1,"highlight_end":52},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use the closure reference itself as metafactory. For now I did","highlight_start":1,"highlight_end":79},{"text":"            /// not notice any issues with this, but the Rc can be put into some","highlight_start":1,"highlight_end":81},{"text":"            /// wrapper struct, and then we could implement MetaFactory for that.","highlight_start":1,"highlight_end":82},{"text":"            impl<$($_A:'static), +, T:'static> MetaFactory for Rc<RefCell<|$($_AT), +|:'static -> T>> {","highlight_start":1,"highlight_end":104},{"text":"                fn get_type(&self) -> TypeDef {","highlight_start":1,"highlight_end":48},{"text":"                    TypeDef::of::<T>()","highlight_start":1,"highlight_end":39},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn get_arg_types(&self) -> Vec<TypeDef> {","highlight_start":1,"highlight_end":58},{"text":"                    // Just go over the types and output TypeDefs for them.","highlight_start":1,"highlight_end":76},{"text":"                    vec![$(TypeDef::of::<$_AT>()), +]","highlight_start":1,"highlight_end":54},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                #[allow(unused_assignments)]","highlight_start":1,"highlight_end":45},{"text":"                fn new(&self, arg_getters: Vec<Box<Any>>) -> Result<Box<Any>, FactoryErrorKind> {","highlight_start":1,"highlight_end":98},{"text":"                    // Calculate required argument count from specified type count.","highlight_start":1,"highlight_end":84},{"text":"                    let required_argc = count_exprs!($($_A),+);","highlight_start":1,"highlight_end":64},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Return error if count does not match.","highlight_start":1,"highlight_end":61},{"text":"                    assert_arg_count!(required_argc, arg_getters.len());","highlight_start":1,"highlight_end":73},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let mut getters = arg_getters;","highlight_start":1,"highlight_end":51},{"text":"                    let mut arg_index = 0;","highlight_start":1,"highlight_end":43},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a; // Factory object of correct type.","highlight_start":1,"highlight_end":68},{"text":"                        { // Scope so we can reuse `maybe_factory`.","highlight_start":1,"highlight_end":68},{"text":"                            let maybe_factory = getters.remove(0);","highlight_start":1,"highlight_end":67},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            // Return error if factory does not have a correct type.","highlight_start":1,"highlight_end":85},{"text":"                            $_a = try_unwrap_factory!($_AT, maybe_factory, arg_index);","highlight_start":1,"highlight_end":87},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            arg_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Build factory instance for THIS closure copy, passing","highlight_start":1,"highlight_end":77},{"text":"                    // all parent factories as arguments.","highlight_start":1,"highlight_end":58},{"text":"                    let factory = box Factory::<T>::new(","highlight_start":1,"highlight_end":57},{"text":"                        box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":60},{"text":"                            $(","highlight_start":1,"highlight_end":31},{"text":"                                $_a: $_a,","highlight_start":1,"highlight_end":42},{"text":"                            )+","highlight_start":1,"highlight_end":31},{"text":"                            closure: self.clone(),","highlight_start":1,"highlight_end":51},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    ) as Box<Any>;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    Ok(factory)","highlight_start":1,"highlight_end":32},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn new_aggregate(&self) -> Aggregate<'static> {","highlight_start":1,"highlight_end":64},{"text":"                    Aggregate::new::<T>()","highlight_start":1,"highlight_end":42},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Use GetterScope as a value getter. This is part","highlight_start":1,"highlight_end":64},{"text":"            /// that is actually used at runtime, and would benefit from","highlight_start":1,"highlight_end":73},{"text":"            /// any further optimizations.","highlight_start":1,"highlight_end":43},{"text":"            impl<'a, $($_A:'static), +, T: 'static> Getter<T> for $GetterScope<$($_AT), +, T> {","highlight_start":1,"highlight_end":96},{"text":"                fn take(&self) -> T {","highlight_start":1,"highlight_end":38},{"text":"                    (*(self.closure.borrow_mut().deref_mut()))(","highlight_start":1,"highlight_end":64},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            self.$_a.take()","highlight_start":1,"highlight_end":44},{"text":"                        ),+","highlight_start":1,"highlight_end":28},{"text":"                    )","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                fn boxed_clone(&self) -> Box<Getter<T> + 'static> {","highlight_start":1,"highlight_end":68},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        let $_a = &self.$_a;","highlight_start":1,"highlight_end":45},{"text":"                    )+","highlight_start":1,"highlight_end":23},{"text":"                    box $GetterScope::<$($_AT), +, T> {","highlight_start":1,"highlight_end":56},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $_a: $_a.clone()","highlight_start":1,"highlight_end":45},{"text":"                        ),","highlight_start":1,"highlight_end":27},{"text":"                        +,","highlight_start":1,"highlight_end":27},{"text":"                        closure: self.closure.clone(),","highlight_start":1,"highlight_end":55},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    );","highlight_start":1,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected type, found `|`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_closure/manyarg.rs:97:67\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m            impl<$($_A:'static), +, T:'static> ToMetaFactory for (|$($_AT), +|:'static -> T) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m296\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mmany_arg_closure_impl!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m297\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GetterScope12:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m298\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A1, A1, a1 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m299\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A2, A2, a2 |\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m309\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    A12, A12, a12\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m310\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `many_arg_closure_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"malformed `stable` attribute input","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":940,"byte_end":949,"line_start":40,"line_end":40,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"#[stable]","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"must be of the form","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":940,"byte_end":949,"line_start":40,"line_end":40,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"#[stable]","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"#[stable(feature = \"name\", since = \"version\")]","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: malformed `stable` attribute input\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs:40:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[stable]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: must be of the form: `#[stable(feature = \"name\", since = \"version\")]`\u001b[0m\n\n"}
{"message":"malformed `stable` attribute input","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":6084,"byte_end":6093,"line_start":193,"line_end":193,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"#[stable]","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"must be of the form","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":6084,"byte_end":6093,"line_start":193,"line_end":193,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"#[stable]","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"#[stable(feature = \"name\", since = \"version\")]","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: malformed `stable` attribute input\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:193:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m193\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[stable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: must be of the form: `#[stable(feature = \"name\", since = \"version\")]`\u001b[0m\n\n"}
{"message":"malformed `stable` attribute input","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":6167,"byte_end":6176,"line_start":198,"line_end":198,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"#[stable]","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"must be of the form","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":6167,"byte_end":6176,"line_start":198,"line_end":198,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"#[stable]","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":"#[stable(feature = \"name\", since = \"version\")]","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: malformed `stable` attribute input\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:198:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[stable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: must be of the form: `#[stable(feature = \"name\", since = \"version\")]`\u001b[0m\n\n"}
{"message":"malformed `unstable` attribute input","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":9250,"byte_end":9261,"line_start":295,"line_end":295,"column_start":1,"column_end":12,"is_primary":true,"text":[{"text":"#[unstable]","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"must be of the form","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":9250,"byte_end":9261,"line_start":295,"line_end":295,"column_start":1,"column_end":12,"is_primary":true,"text":[{"text":"#[unstable]","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":"#[unstable(feature = \"name\", reason = \"...\", issue = \"N\")]","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: malformed `unstable` attribute input\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:295:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m295\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[unstable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: must be of the form: `#[unstable(feature = \"name\", reason = \"...\", issue = \"N\")]`\u001b[0m\n\n"}
{"message":"malformed `unstable` attribute input","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":9718,"byte_end":9729,"line_start":311,"line_end":311,"column_start":1,"column_end":12,"is_primary":true,"text":[{"text":"#[unstable]","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"must be of the form","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":9718,"byte_end":9729,"line_start":311,"line_end":311,"column_start":1,"column_end":12,"is_primary":true,"text":[{"text":"#[unstable]","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":"#[unstable(feature = \"name\", reason = \"...\", issue = \"N\")]","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: malformed `unstable` attribute input\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:311:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m311\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[unstable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: must be of the form: `#[unstable(feature = \"name\", reason = \"...\", issue = \"N\")]`\u001b[0m\n\n"}
{"message":"unresolved import `std::boxed::BoxAny`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":5363,"byte_end":5369,"line_start":162,"line_end":162,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"use std::boxed::{ BoxAny };","highlight_start":19,"highlight_end":25}],"label":"no `BoxAny` in `boxed`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `std::boxed::BoxAny`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:162:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m162\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::boxed::{ BoxAny };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `BoxAny` in `boxed`\u001b[0m\n\n"}
{"message":"unresolved import `std::boxed::BoxAny`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs","byte_start":122,"byte_end":140,"line_start":5,"line_end":5,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"use std::boxed::BoxAny;","highlight_start":5,"highlight_end":23}],"label":"no `BoxAny` in `boxed`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this unresolved item through its public re-export instead","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs","byte_start":122,"byte_end":140,"line_start":5,"line_end":5,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"use std::boxed::BoxAny;","highlight_start":5,"highlight_end":23}],"label":null,"suggested_replacement":"BoxAny","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m: unresolved import `std::boxed::BoxAny`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs:5:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::boxed::BoxAny;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `BoxAny` in `boxed`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this unresolved item through its public re-export instead\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0muse \u001b[0m\u001b[0m\u001b[38;5;10mBoxAny\u001b[0m\u001b[0m;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~\u001b[0m\n\n"}
{"message":"cannot find attribute `experimental` in this scope","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":761,"byte_end":773,"line_start":29,"line_end":29,"column_start":3,"column_end":15,"is_primary":true,"text":[{"text":"#[experimental]","highlight_start":3,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: cannot find attribute `experimental` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs:29:3\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[experimental]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"cannot find attribute `experimental` in this scope","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":831,"byte_end":843,"line_start":34,"line_end":34,"column_start":3,"column_end":15,"is_primary":true,"text":[{"text":"#[experimental]","highlight_start":3,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: cannot find attribute `experimental` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs:34:3\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[experimental]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"cannot find attribute `experimental` in this scope","code":null,"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":5571,"byte_end":5583,"line_start":176,"line_end":176,"column_start":3,"column_end":15,"is_primary":true,"text":[{"text":"#[experimental]","highlight_start":3,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: cannot find attribute `experimental` in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:176:3\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m176\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[experimental]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"cannot find type `uint` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/error/mod.rs","byte_start":194,"byte_end":198,"line_start":8,"line_end":8,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"    pub expected: uint,","highlight_start":19,"highlight_end":23}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `uint` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/error/mod.rs:8:19\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub expected: uint,\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `uint` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/error/mod.rs","byte_start":219,"byte_end":223,"line_start":9,"line_end":9,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"    pub specified: uint,","highlight_start":20,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `uint` in this scope\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/error/mod.rs:9:20\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub specified: uint,\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `uint` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/error/mod.rs","byte_start":376,"byte_end":380,"line_start":16,"line_end":16,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"    pub argument_index: uint,","highlight_start":25,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `uint` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/error/mod.rs:16:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub argument_index: uint,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `uint` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/error/mod.rs","byte_start":498,"byte_end":502,"line_start":21,"line_end":21,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"    pub fn new(expected: uint, specified: uint) -> ArgCountMismatch {","highlight_start":26,"highlight_end":30}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `uint` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/error/mod.rs:21:26\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(expected: uint, specified: uint) -> ArgCountMismatch {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `uint` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/error/mod.rs","byte_start":515,"byte_end":519,"line_start":21,"line_end":21,"column_start":43,"column_end":47,"is_primary":true,"text":[{"text":"    pub fn new(expected: uint, specified: uint) -> ArgCountMismatch {","highlight_start":43,"highlight_end":47}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `uint` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/error/mod.rs:21:43\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(expected: uint, specified: uint) -> ArgCountMismatch {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"cannot find type `uint` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/error/mod.rs","byte_start":796,"byte_end":800,"line_start":31,"line_end":31,"column_start":56,"column_end":60,"is_primary":true,"text":[{"text":"    pub fn new(expected_type: TypeDef, argument_index: uint) -> ArgTypeMismatch {","highlight_start":56,"highlight_end":60}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m: cannot find type `uint` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/error/mod.rs:31:56\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(expected_type: TypeDef, argument_index: uint) -> ArgTypeMismatch {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\n"}
{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":5243,"byte_end":5267,"line_start":156,"line_end":156,"column_start":1,"column_end":25,"is_primary":true,"text":[{"text":"#![feature(macro_rules)]","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the feature `macro_rules` has been stable since `1.0.0` and no longer requires an attribute to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"remove the attribute","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":5243,"byte_end":5267,"line_start":156,"line_end":156,"column_start":1,"column_end":25,"is_primary":true,"text":[{"text":"#![feature(macro_rules)]","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:156:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(macro_rules)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: remove the attribute\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the feature `macro_rules` has been stable since `1.0.0` and no longer requires an attribute to enable\u001b[0m\n\n"}
{"message":"`#![feature]` may not be used on the stable release channel","code":{"code":"E0554","explanation":"Feature attributes are only allowed on the nightly release channel. Stable or\nbeta compilers will not comply.\n\nErroneous code example:\n\n```ignore (depends on release channel)\n#![feature(lang_items)] // error: `#![feature]` may not be used on the\n                        //        stable release channel\n```\n\nIf you need the feature, make sure to use a nightly release of the compiler\n(but be warned that the feature may be removed or altered in the future).\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":5268,"byte_end":5297,"line_start":157,"line_end":157,"column_start":1,"column_end":30,"is_primary":true,"text":[{"text":"#![feature(unboxed_closures)]","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0554]\u001b[0m\u001b[0m\u001b[1m: `#![feature]` may not be used on the stable release channel\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:157:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m157\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#![feature(unboxed_closures)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"stability attributes may not be used outside of the standard library","code":{"code":"E0734","explanation":"A stability attribute has been used outside of the standard library.\n\nErroneous code example:\n\n```compile_fail,E0734\n#[stable(feature = \"a\", since = \"b\")] // invalid\n#[unstable(feature = \"b\", issue = \"none\")] // invalid\nfn foo(){}\n```\n\nThese attributes are meant to only be used by the standard library and are\nrejected in your own crates.\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs","byte_start":940,"byte_end":949,"line_start":40,"line_end":40,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"#[stable]","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0734]\u001b[0m\u001b[0m\u001b[1m: stability attributes may not be used outside of the standard library\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/from_clone/mod.rs:40:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[stable]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\n\n"}
{"message":"stability attributes may not be used outside of the standard library","code":{"code":"E0734","explanation":"A stability attribute has been used outside of the standard library.\n\nErroneous code example:\n\n```compile_fail,E0734\n#[stable(feature = \"a\", since = \"b\")] // invalid\n#[unstable(feature = \"b\", issue = \"none\")] // invalid\nfn foo(){}\n```\n\nThese attributes are meant to only be used by the standard library and are\nrejected in your own crates.\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":6084,"byte_end":6093,"line_start":193,"line_end":193,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"#[stable]","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0734]\u001b[0m\u001b[0m\u001b[1m: stability attributes may not be used outside of the standard library\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:193:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m193\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[stable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\n\n"}
{"message":"stability attributes may not be used outside of the standard library","code":{"code":"E0734","explanation":"A stability attribute has been used outside of the standard library.\n\nErroneous code example:\n\n```compile_fail,E0734\n#[stable(feature = \"a\", since = \"b\")] // invalid\n#[unstable(feature = \"b\", issue = \"none\")] // invalid\nfn foo(){}\n```\n\nThese attributes are meant to only be used by the standard library and are\nrejected in your own crates.\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":6167,"byte_end":6176,"line_start":198,"line_end":198,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"#[stable]","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0734]\u001b[0m\u001b[0m\u001b[1m: stability attributes may not be used outside of the standard library\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:198:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m198\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[stable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\n\n"}
{"message":"stability attributes may not be used outside of the standard library","code":{"code":"E0734","explanation":"A stability attribute has been used outside of the standard library.\n\nErroneous code example:\n\n```compile_fail,E0734\n#[stable(feature = \"a\", since = \"b\")] // invalid\n#[unstable(feature = \"b\", issue = \"none\")] // invalid\nfn foo(){}\n```\n\nThese attributes are meant to only be used by the standard library and are\nrejected in your own crates.\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":9290,"byte_end":9301,"line_start":297,"line_end":297,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"    #[unstable]","highlight_start":5,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0734]\u001b[0m\u001b[0m\u001b[1m: stability attributes may not be used outside of the standard library\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:297:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m297\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[unstable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"stability attributes may not be used outside of the standard library","code":{"code":"E0734","explanation":"A stability attribute has been used outside of the standard library.\n\nErroneous code example:\n\n```compile_fail,E0734\n#[stable(feature = \"a\", since = \"b\")] // invalid\n#[unstable(feature = \"b\", issue = \"none\")] // invalid\nfn foo(){}\n```\n\nThese attributes are meant to only be used by the standard library and are\nrejected in your own crates.\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":9341,"byte_end":9352,"line_start":299,"line_end":299,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"    #[unstable]","highlight_start":5,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0734]\u001b[0m\u001b[0m\u001b[1m: stability attributes may not be used outside of the standard library\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:299:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m299\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[unstable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"stability attributes may not be used outside of the standard library","code":{"code":"E0734","explanation":"A stability attribute has been used outside of the standard library.\n\nErroneous code example:\n\n```compile_fail,E0734\n#[stable(feature = \"a\", since = \"b\")] // invalid\n#[unstable(feature = \"b\", issue = \"none\")] // invalid\nfn foo(){}\n```\n\nThese attributes are meant to only be used by the standard library and are\nrejected in your own crates.\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":9402,"byte_end":9413,"line_start":301,"line_end":301,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"    #[unstable]","highlight_start":5,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0734]\u001b[0m\u001b[0m\u001b[1m: stability attributes may not be used outside of the standard library\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:301:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m301\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[unstable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"stability attributes may not be used outside of the standard library","code":{"code":"E0734","explanation":"A stability attribute has been used outside of the standard library.\n\nErroneous code example:\n\n```compile_fail,E0734\n#[stable(feature = \"a\", since = \"b\")] // invalid\n#[unstable(feature = \"b\", issue = \"none\")] // invalid\nfn foo(){}\n```\n\nThese attributes are meant to only be used by the standard library and are\nrejected in your own crates.\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":9503,"byte_end":9514,"line_start":303,"line_end":303,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"    #[unstable]","highlight_start":5,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0734]\u001b[0m\u001b[0m\u001b[1m: stability attributes may not be used outside of the standard library\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:303:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m303\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[unstable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"stability attributes may not be used outside of the standard library","code":{"code":"E0734","explanation":"A stability attribute has been used outside of the standard library.\n\nErroneous code example:\n\n```compile_fail,E0734\n#[stable(feature = \"a\", since = \"b\")] // invalid\n#[unstable(feature = \"b\", issue = \"none\")] // invalid\nfn foo(){}\n```\n\nThese attributes are meant to only be used by the standard library and are\nrejected in your own crates.\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":9250,"byte_end":9261,"line_start":295,"line_end":295,"column_start":1,"column_end":12,"is_primary":true,"text":[{"text":"#[unstable]","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0734]\u001b[0m\u001b[0m\u001b[1m: stability attributes may not be used outside of the standard library\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:295:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m295\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[unstable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"stability attributes may not be used outside of the standard library","code":{"code":"E0734","explanation":"A stability attribute has been used outside of the standard library.\n\nErroneous code example:\n\n```compile_fail,E0734\n#[stable(feature = \"a\", since = \"b\")] // invalid\n#[unstable(feature = \"b\", issue = \"none\")] // invalid\nfn foo(){}\n```\n\nThese attributes are meant to only be used by the standard library and are\nrejected in your own crates.\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":9926,"byte_end":9937,"line_start":316,"line_end":316,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"    #[unstable]","highlight_start":5,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0734]\u001b[0m\u001b[0m\u001b[1m: stability attributes may not be used outside of the standard library\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:316:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m316\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[unstable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"stability attributes may not be used outside of the standard library","code":{"code":"E0734","explanation":"A stability attribute has been used outside of the standard library.\n\nErroneous code example:\n\n```compile_fail,E0734\n#[stable(feature = \"a\", since = \"b\")] // invalid\n#[unstable(feature = \"b\", issue = \"none\")] // invalid\nfn foo(){}\n```\n\nThese attributes are meant to only be used by the standard library and are\nrejected in your own crates.\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs","byte_start":9718,"byte_end":9729,"line_start":311,"line_end":311,"column_start":1,"column_end":12,"is_primary":true,"text":[{"text":"#[unstable]","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0734]\u001b[0m\u001b[0m\u001b[1m: stability attributes may not be used outside of the standard library\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/lib.rs:311:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m311\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[unstable]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"trait takes 1 generic argument but 2 generic arguments were supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs","byte_start":3901,"byte_end":3903,"line_start":100,"line_end":100,"column_start":17,"column_end":19,"is_primary":true,"text":[{"text":"    do_new: Box<Fn<(Vec<Box<Any>>,),Box<Any>> + 'a>,","highlight_start":17,"highlight_end":19}],"label":"expected 1 generic argument","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"trait defined here, with 1 generic parameter: `Args`","code":null,"level":"note","spans":[{"file_name":"/home/zinnusl/snap/rustup/common/rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs","byte_start":2689,"byte_end":2693,"line_start":76,"line_end":76,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"pub trait Fn<Args: Tuple>: FnMut<Args> {","highlight_start":14,"highlight_end":18}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/zinnusl/snap/rustup/common/rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs","byte_start":2686,"byte_end":2688,"line_start":76,"line_end":76,"column_start":11,"column_end":13,"is_primary":true,"text":[{"text":"pub trait Fn<Args: Tuple>: FnMut<Args> {","highlight_start":11,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove this generic argument","code":null,"level":"help","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs","byte_start":3921,"byte_end":3929,"line_start":100,"line_end":100,"column_start":37,"column_end":45,"is_primary":true,"text":[{"text":"    do_new: Box<Fn<(Vec<Box<Any>>,),Box<Any>> + 'a>,","highlight_start":37,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0107]\u001b[0m\u001b[0m\u001b[1m: trait takes 1 generic argument but 2 generic arguments were supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs:100:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m100\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    do_new: Box<Fn<(Vec<Box<Any>>,),Box<Any>> + 'a>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this generic argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 1 generic argument\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: trait defined here, with 1 generic parameter: `Args`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/snap/rustup/common/rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:76:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait Fn<Args: Tuple>: FnMut<Args> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\n\n"}
{"message":"the value of the associated type `Output` (from trait `FnOnce`) must be specified","code":{"code":"E0191","explanation":"An associated type wasn't specified for a trait object.\n\nErroneous code example:\n\n```compile_fail,E0191\ntrait Trait {\n    type Bar;\n}\n\ntype Foo = Trait; // error: the value of the associated type `Bar` (from\n                  //        the trait `Trait`) must be specified\n```\n\nTrait objects need to have all associated types specified. Please verify that\nall associated types of the trait were specified and the correct trait was used.\nExample:\n\n```\ntrait Trait {\n    type Bar;\n}\n\ntype Foo = Trait<Bar=i32>; // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs","byte_start":3901,"byte_end":3930,"line_start":100,"line_end":100,"column_start":17,"column_end":46,"is_primary":true,"text":[{"text":"    do_new: Box<Fn<(Vec<Box<Any>>,),Box<Any>> + 'a>,","highlight_start":17,"highlight_end":46}],"label":"associated type `Output` must be specified","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0191]\u001b[0m\u001b[0m\u001b[1m: the value of the associated type `Output` (from trait `FnOnce`) must be specified\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zinnusl/.cargo/registry/src/index.crates.io-6f17d22bba15001f/metafactory-0.4.4/src/aggregate/mod.rs:100:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m100\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    do_new: Box<Fn<(Vec<Box<Any>>,),Box<Any>> + 'a>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated type `Output` must be specified\u001b[0m\n\n"}
{"message":"aborting due to 64 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 64 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0107, E0191, E0412, E0432, E0554, E0734.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0107, E0191, E0412, E0432, E0554, E0734.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0107`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0107`.\u001b[0m\n"}
